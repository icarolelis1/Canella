#version 450
#extension GL_EXT_shader_16bit_storage: require
#extension GL_EXT_shader_8bit_storage: require
#extension GL_EXT_mesh_shader : require
#extension GL_GOOGLE_include_directive: require
#extension GL_ARB_shader_draw_parameters: require
//gl_DRAWIDARB

layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = 64, max_primitives = 128) out;

#include "common.glsl"

layout (set = 0 ,binding = 0) uniform UBO
{
    mat4 view_projection;
    vec4 eye;
    mat4 projection;
    mat4 view;
} ubo;

layout(std430,set = 2 ,binding = 0) readonly  buffer Model_Matrixes
{
	mat4 model_Matrices[];
};

layout(std430,set = 3 ,binding = 0) readonly  buffer Meshlets
{
	Meshlet meshlets[];
};

layout(std430, set = 3 ,binding = 1) readonly  buffer Vertices
{
	Vertex vertices[];
};

layout(set = 3 ,binding = 2) readonly  buffer Bounds
{
	MeshletBound bounds[];
};

layout( set = 3 ,binding = 3) readonly buffer MeshletIndices
{
	uint8_t meshlet_indices[];
};

layout( set = 3 ,binding = 4) readonly buffer MeshletVertices
{
	uint meshlet_vertices[];
};
layout( set = 3 ,binding = 5) readonly buffer MeshDrawCommand
{
	IndirectDrawDispatch draw_commands[];
};

layout( set = 3 ,binding = 6) readonly buffer MeshData
{
	StaticMeshData static_meshes[];
};

layout(location = 0) out VertexOutput
{
	vec3 world_pos;
	vec2 uv;
	vec3 normal;

} vertexOutput[];

struct Task
{
   uint meshletIndices[32];

};
taskPayloadSharedEXT Task IN;


layout( push_constant ) uniform block
 {
    SpecializedDrawTasks specialize_mesh;
 };


uint hash(uint a)
{
   a = (a+0x7ed55d16) + (a<<12);
   a = (a^0xc761c23c) ^ (a>>19);
   a = (a+0x165667b1) + (a<<5);
   a = (a+0xd3a2646c) ^ (a<<9);
   a = (a+0xfd7046c5) + (a<<3);
   a = (a^0xb55a4f09) ^ (a>>16);
   return a;
}
void main()
{

 StaticMeshData mesh = static_meshes[draw_commands[gl_DrawIDARB].draw_id];
 uint ti = gl_LocalInvocationID.x;
 uint mgi = gl_WorkGroupID.x;    
 uint mi = IN.meshletIndices[mgi];
 Meshlet meshlet = meshlets[mi];

 mat4 model;
 if(specialize_mesh.dyamic == false)
    model = model_Matrices[mesh.mesh_id];
 else
    model = specialize_mesh.model_matrix;
 mat4 vp = ubo.view_projection;

if( ti < meshlet.vertex_count )
{
  	uint vertex_indice = uint(meshlet_vertices[meshlet.vertex_offset + ti + mesh.meshlet_vertices_offset]);
	vec3 fragPos = vec3(model * vec4(vertices[vertex_indice + mesh.vertex_offset].position.xyz + mesh.pos,1.0));
  	gl_MeshVerticesEXT[ti].gl_Position = vp * vec4(fragPos,1.0)  ;

	uint mhash = hash(mi);
	vertexOutput[ti].world_pos = fragPos;
	vertexOutput[ti].uv = vertices[vertex_indice].uv.xy;
	vertexOutput[ti].normal = normalize(mat3(model) * vertices[vertex_indice].normal.xyz).xyz;
}

if ( ti < meshlet.triangle_count )
{
	uint index_offset =  mesh.meshlet_triangles_offset;
	gl_PrimitiveTriangleIndicesEXT[ti] = uvec3(	
	 											uint( meshlet_indices[index_offset + meshlet.triangle_offset + ti*3 ]),
	 											uint( meshlet_indices[index_offset + meshlet.triangle_offset + ti*3 + 1 ]),
	 											uint( meshlet_indices[index_offset + meshlet.triangle_offset + ti*3 + 2 ]));

}

 if(gl_LocalInvocationID.x == 0 );
  	SetMeshOutputsEXT(meshlet.vertex_count, meshlet.triangle_count);
}

