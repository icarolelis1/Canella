#version 450
#extension GL_EXT_shader_16bit_storage: require
#extension GL_EXT_shader_8bit_storage: require
#extension GL_EXT_mesh_shader : require
#extension GL_GOOGLE_include_directive: require
#extension GL_ARB_shader_draw_parameters: require
//gl_DRAWIDARB

layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = 64, max_primitives = 128) out;

#include "common.glsl"

layout (set = 0 ,binding = 0) uniform UBO 
{
	mat4 view_projection;
	vec4 eye;
} ubo;

layout(std430,set = 1 ,binding = 0) readonly  buffer Model_Matrixes
{
	mat4 model_Matrices[];
};

layout(std430,set = 2 ,binding = 0) readonly  buffer Meshlets
{
	Meshlet meshlets[];
};

layout(std430, set = 2 ,binding = 1) readonly  buffer Vertices
{
	Vertex vertices[];
};

layout(set = 2 ,binding = 2) readonly  buffer Bounds
{
	MeshletBound bounds[];
};

layout( set = 2 ,binding = 3) readonly buffer MeshletIndices
{
	uint8_t meshlet_indices[];
};

layout( set = 2 ,binding = 4) readonly buffer MeshletVertices
{
	uint meshlet_vertices[];
};
layout( set = 2 ,binding = 5) readonly buffer MeshDrawCommand
{
	IndirectDrawDispatch draw_commands[];
};

layout( set = 2 ,binding = 6) readonly buffer MeshData
{
	StaticMeshData static_meshes[];
};

layout(location = 0) out VertexOutput
{
	vec4 color;
} vertexOutput[];

struct Task
{
   uint meshletIndices[32];

};
taskPayloadSharedEXT Task IN;


uint hash(uint a)
{
   a = (a+0x7ed55d16) + (a<<12);
   a = (a^0xc761c23c) ^ (a>>19);
   a = (a+0x165667b1) + (a<<5);
   a = (a+0xd3a2646c) ^ (a<<9);
   a = (a+0xfd7046c5) + (a<<3);
   a = (a^0xb55a4f09) ^ (a>>16);
   return a;
}
void main()
{

 StaticMeshData mesh = static_meshes[draw_commands[gl_DrawIDARB].draw_id];
 uint ti = gl_LocalInvocationID.x;
 uint mgi = gl_WorkGroupID.x;    
 uint mi = IN.meshletIndices[mgi];
 Meshlet meshlet = meshlets[mi];
 
 mat4 model = model_Matrices[mesh.mesh_id];
 mat4 mvp = ubo.view_projection;

if( ti < meshlet.vertex_count )
{
  	uint vertex_indice = uint(meshlet_vertices[meshlet.vertex_offset + ti + mesh.meshlet_vertices_offset]);
	vec3 fragPos = vec3(model * vec4(vertices[vertex_indice + mesh.vertex_offset].position.xyz + mesh.pos,1.0));
  	gl_MeshVerticesEXT[ti].gl_Position = mvp * vec4(fragPos,1.0)  ;
	
	uint mhash = hash(mi);
	vec3 mcolor = vec3(float(mhash & 255), float((mhash >> 8) & 255), float((mhash >> 16) & 255)) / 255.0;
	vertexOutput[ti].color = vec4(mcolor,1);

}

if (ti < meshlet.triangle_count)
{
	uint index_offset =  mesh.meshlet_triangles_offset;
	gl_PrimitiveTriangleIndicesEXT[ti] = uvec3(	
	 											uint(meshlet_indices[index_offset + meshlet.triangle_offset + ti*3 + 0 ]) , 
	 											uint(meshlet_indices[index_offset + meshlet.triangle_offset + ti*3 + 1 ]) ,
	 											uint(meshlet_indices[index_offset + meshlet.triangle_offset + ti*3 + 2 ])  );

}

 if(gl_LocalInvocationID.x == 0 );
  	SetMeshOutputsEXT(meshlet.vertex_count, meshlet.triangle_count);
}

