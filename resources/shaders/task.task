/* Copyright (c) 2021, Sascha Willems
 *
 * SPDX-License-Identifier: MIT
 */

#version 450
#extension GL_EXT_shader_16bit_storage: require
#extension GL_EXT_shader_8bit_storage: require
#extension GL_EXT_mesh_shader : require
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_GOOGLE_include_directive: require


#include "common.glsl"
#define GPU_WARP_SIZE 32
#define GPU_GROUP_SIZE GPU_WARP_SIZE
#define CULL 1
layout(local_size_x = 1 ,local_size_y = 1 , local_size_z = 1 ) in;

#define GPU_PRIMITIVES_PER_MESHLET GPU_GROUP_SIZE

#define GPU_MESHLETS_PER_INVOCATION 3
#define GPU_MESHLETS_PER_WORKGROUP (GPU_GROUP_SIZE * GPU_MESHLETS_PER_INVOCATION)

#define GPU_INDICES_PER_PRIMITIVE 3
const float pi_half = 1.57079;

layout (set = 0 ,binding = 0) uniform UBO 
{
	mat4 projection;
	mat4 model;
	mat4 view;
} ubo;

layout(set = 1 ,binding = 0)readonly  buffer Meshlets
{
	Meshlet meshlets[];
};


layout( set = 1 ,binding = 1) readonly buffer Vertices
{
	Vertex vertices[];
};

layout(set = 1 ,binding = 2) readonly  buffer Indices
{
	uint8_t indices[];
};

struct Task
{
   uint meshletIndices[32];
};
taskPayloadSharedEXT Task OUT;


void main()
{
   uint thread_index = gl_LocalInvocationID.x;
  uint group_index = gl_WorkGroupID.x;

   // each group process one meshlet. group_index * 32  is the offset. e
   uint meshlet_index = group_index * 32 * thread_index;
 
  bool accept = true;

  uvec4 voteMeshlets = subgroupBallot(accept);
  uint  numMeshlets  = subgroupBallotBitCount(voteMeshlets);

   OUT.meshletIndices[0] = 0; 
   if(gl_LocalInvocationID.x == 0){
      EmitMeshTasksEXT(2, 1, 1);
    }
  
}
