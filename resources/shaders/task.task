#version 450
#extension GL_EXT_shader_16bit_storage: require
#extension GL_EXT_shader_8bit_storage: require
#extension GL_EXT_mesh_shader : require
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_GOOGLE_include_directive: require
#extension GL_ARB_shader_draw_parameters: require

#include "common.glsl"

layout(local_size_x = 32 ,local_size_y = 1 , local_size_z = 1 ) in;


layout (set = 0 ,binding = 0) uniform UBO 
{
	mat4 view_projection;
	vec4 eye;

} ubo;

layout(std430,set = 1 ,binding = 0) readonly  buffer Model_Matrices
{
	mat4 model_matrices[];
};


layout(set = 2 ,binding = 0)readonly  buffer Meshlets
{
	Meshlet meshlets[];
};

layout(set = 2 ,binding = 2)readonly  buffer Bounds
{
	MeshletBound bounds[];
};

layout( set = 2 ,binding = 5) readonly buffer MeshDrawCommand
{
	IndirectDrawDispatch draw_commands[];
};

layout( set = 2 ,binding = 6) readonly buffer MeshData
{
	StaticMeshData static_meshes[];
};

 layout( push_constant ) uniform block
 {
    SpecializedDrawTasks specialize_mesh;
 };



struct Task
{
   uint meshletIndices[32];
};

taskPayloadSharedEXT Task OUT;

bool cone_cull(vec3 center, float radius, vec3 cone_axis, float cone_cutoff, vec3 camera_position)
{
	return dot(normalize(center - camera_position), normalize(cone_axis)) >= cone_cutoff* length(center - camera_position) + radius ;
}


void main()
{
   StaticMeshData mesh_data = static_meshes[draw_commands[gl_DrawIDARB].draw_id];
   uint mgi = gl_WorkGroupID.x;   
   uint ti = gl_LocalInvocationID.x; 
   uint mi = mgi * 32 + ti;
   uint thread_meshlet = mi + mesh_data.meshlet_offset ;
  MeshletBound bound = bounds[thread_meshlet];


 mat4 model;
 if(specialize_mesh.dyamic == false)
    model = model_matrices[mesh_data.mesh_id];
 else
    model = specialize_mesh.model_matrix;

  vec4 cone_apex = model * vec4(bound.cone_apex.xyz,1);
  vec3 center = bound.center.xyz +  model[3].xyz;
  float radius = bound.cone_cutoff.y;
  vec4 cone_axis = normalize(vec4((mat3(model)) * bound.cone_axis.xyz ,1.0));
  bool accept = !cone_cull(center,radius, cone_axis.xyz,bound.cone_cutoff.x,ubo.eye.xyz);

   uvec4 ballot = subgroupBallot(accept);
   uint count = subgroupBallotBitCount(ballot);
   uint index = subgroupBallotInclusiveBitCount(ballot);

   if(accept)
      OUT.meshletIndices[ti] = thread_meshlet ;

   if( ti == 0 );
          EmitMeshTasksEXT(count, 1, 1);

  // if( ti == 0 );
    //      EmitMeshTasksEXT(min(32,mesh_data.meshlet_count - mi ), 1, 1);
}
