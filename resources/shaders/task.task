/* Copyright (c) 2021, Sascha Willems
 *
 * SPDX-License-Identifier: MIT
 *
 */
#version 460
#extension GL_EXT_mesh_shader : require
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_shader_subgroup_ballot : require


#include "common.glsl"
#define GPU_WARP_SIZE 32
#define GPU_GROUP_SIZE GPU_WARP_SIZE
#define CULL 1
layout(local_size_x=GPU_GROUP_SIZE) in;

#define GPU_PRIMITIVES_PER_MESHLET GPU_GROUP_SIZE

#define GPU_MESHLETS_PER_INVOCATION 3
#define GPU_MESHLETS_PER_WORKGROUP (GPU_GROUP_SIZE * GPU_MESHLETS_PER_INVOCATION)

#define GPU_INDICES_PER_PRIMITIVE 3
const float pi_half = 1.57079;


layout(set = 0 ,binding = 0, std430) readonly buffer mesh_data
{
	MeshDrawInstance mesh_instances[];
};

layout(set = 1 ,binding = 0, std430) readonly buffer meshlets_data
{
	Meshlet meshlets[];
};

struct Task
{
   uint meshletIndices[32];
};

taskPayloadSharedEXT Task OUT;


void main()
{
  uint thread_index = gl_LocalInvocationID.x;
  uint group_index = gl_WorkGroupID.x;

  // each group process one meshlet. group_index * 32  is the offset. e
  uint meshlet_index = group_index * 32 * thread_index;

  //todo Culling here
  // mat4 model = mesh_instances[push.mesh_id].model ;
  // vec4 world_center = model * vec4(meshlets[meshlet_index].center,1);
  // float scale = length(model[0]);
  // float radius = meshlets[meshlet_index].radius * 1.1;
  // vec3 cone_axis = mat3( model ) * vec3(int(meshlets[meshlet_index].cone_axis[0]) / 127.0, int(meshlets[meshlet_index].cone_axis[1]) / 127.0, int(meshlets[meshlet_index].cone_axis[2]) / 127.0);
  // float cone_cutoff = int(meshlets[meshlet_index].cone_cutoff) / 127.0;

  // bool accept = false;
  OUT.meshletIndices[thread_index] = meshlet_index; 
  if(gl_LocalInvocationID.x == 0){
    EmitMeshTasksEXT(32, 1, 1);
  }
  
//   uint meshlet_id = gl_GlobalInvocationID.x;
//   uint workgroup_meshlet_base_id = gl_WorkGroupID.x * GPU_GROUP_SIZE;
//   uint workgroup_primitive_base_id = workgroup_meshlet_base_id * GPU_PRIMITIVES_PER_MESHLET;
//   uint local_primitive_offset = gl_LocalInvocationID.x * GPU_PRIMITIVES_PER_MESHLET;
  
//   bool render = true;
//   uvec4 subgroup_bitfield = subgroupBallot(render);
//   uint task_count = subgroupBallotBitCount(subgroup_bitfield);

//  if(gl_LocalInvocationID.x == 0){
//     EmitMeshTasksEXT(task_count, 1, 1);
//     OUT.primitive_base_id = workgroup_primitive_base_id;
//  }
//   uint task_out_index = subgroupBallotBitCount(subgroup_bitfield & ((1u << gl_SubgroupSize) - 1));
//   if (render) {
//         OUT.primitive_offsets[task_out_index] = local_primitive_offset;
//         OUT.meshlet_ids[task_out_index] = meshlet_id;
//     }
}
