#version 450
#extension GL_EXT_shader_16bit_storage: require
#extension GL_EXT_shader_8bit_storage: require
#extension GL_EXT_shader_atomic_float: require

layout(local_size_x = 32 ,local_size_y = 1 , local_size_z = 1 ) in;
#include "common.glsl"

layout(set = 0 ,binding = 0)readonly  buffer CommandRead
{
	IndirectDrawDispatch commands[];
};

layout(set = 0 ,binding = 1)writeonly  buffer CommandWrite
{
	IndirectDrawDispatch processed_commands[];
};

layout(set = 0 ,binding = 2)  buffer CountBuffer
{
	uint commands_count;
};


layout(std430,set = 1 ,binding = 0) readonly  buffer Model_Matrices
{
	mat4 model_matrices[];
};



layout( push_constant ) uniform Frustums
{
   vec4 frustums[6];
};

bool sphere_frustum_check(vec4 pos,float radius)
{
      for(int i = 0; i < 6; ++i)
      {
			if ( (dot(pos,frustums[i])) > -radius)
         {
		      return false;
         }

      }
            
      return true;
}


void main(){
   
   uint gi = gl_WorkGroupID.x;   
   uint ti = gl_LocalInvocationID.x; 
   uint di = gi * 32 + ti;

   IndirectDrawDispatch command = commands[di];
   vec4 center = model_matrices[command.mesh_id] * vec4(command.cx,command.cy,command.cz,1.0);
   float radius = command.radius * 0.02; 
    
   bool visible = sphere_frustum_check(center,radius);
   
	//uint commands_count = atomicAdd(commands_count, 1);
   processed_commands[di].groupCountX              =  (commands[di].meshlet_count + 31)/32;
   processed_commands[di].groupCountY              = commands[di].groupCountY;
   processed_commands[di].groupCountZ              = commands[di].groupCountZ;
   processed_commands[di].vertex_offset            = commands[di].vertex_offset;
   processed_commands[di].meshlet_triangle_offset  = commands[di].meshlet_triangle_offset;
   processed_commands[di].meshlet_offset           = commands[di].meshlet_offset;
   processed_commands[di].meshlet_vertex_offset    = commands[di].meshlet_vertex_offset;
   processed_commands[di].index_offset             = commands[di].index_offset;
   processed_commands[di].mesh_id                  = commands[di].mesh_id;
   processed_commands[di].meshlet_count            = (commands[di].meshlet_count + 31)/32;

}