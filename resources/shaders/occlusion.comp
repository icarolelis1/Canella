#version 450


layout(local_size_x = 32 ,local_size_y = 1 , local_size_z = 1 ) in;

#include "common.glsl"

layout(set = 0 ,binding = 0) writeonly  buffer CommandsRead
{
	IndirectDrawDispatch processed_commands[];
};

layout(set = 0 ,binding = 1) readonly  buffer MeshData
{
	StaticMeshData static_meshes[];
};

layout(set = 0 ,binding = 2)  buffer CountBuffer
{
	uint commands_count;
};

layout(set = 0 ,binding = 3)  buffer Occlusion_Buffer
{
	uint occlusion_vibility_buffer[];
};

layout (set = 0 , binding = 4) uniform sampler2D depthPyramid;

layout(std430,set = 1 ,binding = 0) readonly  buffer Model_Matrices
{
	mat4 model_matrices[];
};

layout (set = 2 ,binding = 0) uniform UBO
{
    mat4 view_projection;
    vec4 eye;
    mat4 projection;
    mat4 view;
} ubo;

layout( push_constant ) uniform block
{
   CullingData culling_data;
};


bool occlusion_test(mat4 view, mat4 projection, vec3 center,float radius)
{
    //Sphere center in view space
    vec4 view_center = view * vec4(center,1.);
    vec4 eye_pos = ubo.eye;

    float distance_to_sphere = distance(vec3(eye_pos),center);
    vec3 sphere_to_eye = normalize(center - eye_pos.xyz);

    //Compute Camera Coordinate System
    vec3 camera_up    =  normalize(vec3(view[1]));
    vec3 camera_front =  normalize(vec3(view[2]));
    vec3 camera_right =  normalize(vec3(view[0]));

    vec3 v_up_radius    = camera_up * radius;
    vec3 v_right_radius = camera_right * radius;

    //Compute AABB Corners
    vec4 project_center  = projection * vec4(center,1.0);
    vec4 world_corner_0 = vec4( center.xyz + v_up_radius - v_right_radius, 1 ); // Top-Left
    vec4 world_corner_1 = vec4( center.xyz + v_up_radius + v_right_radius, 1 ); // Top-Right
    vec4 world_corner_2 = vec4( center.xyz - v_up_radius - v_right_radius, 1 ); // Bottom-Left
    vec4 world_corner_3 = vec4( center.xyz - v_up_radius + v_right_radius, 1 ); // Bottom-Right

    mat4 view_projection = ubo.view_projection;

    //Project to Clip
    vec4 clip_corner_0 = view_projection * world_corner_0; // Top-Left
    vec4 clip_corner_1 = view_projection * world_corner_1; // Top-Right
    vec4 clip_corner_2 = view_projection * world_corner_2; // Bottom-Left
    vec4 clip_corner_3 = view_projection * world_corner_3; // Bottom-Right

    //NDC Corners
    vec2 ndc_corner_0 = clip_corner_0.xy/clip_corner_0.w; // Top-Left
    vec2 ndc_corner_1 = clip_corner_1.xy/clip_corner_1.w; // Top-Right
    vec2 ndc_corner_2 = clip_corner_2.xy/clip_corner_2.w; // Bottom-Left
    vec2 ndc_corner_3 = clip_corner_3.xy/clip_corner_3.w; // Bottom-Right

    ndc_corner_0 = ndc_corner_0 * vec2(0.5,0.5) + vec2(0.5) ; // Top-Left
    ndc_corner_1 = ndc_corner_1 * vec2(0.5,0.5) + vec2(0.5) ; // Top-Right
    ndc_corner_2 = ndc_corner_2 * vec2(0.5,0.5) + vec2(0.5) ; // Bottom-Left
    ndc_corner_3 = ndc_corner_3 * vec2(0.5,0.5) + vec2(0.5) ; // Bottom-Right

    float width =   distance(ndc_corner_0,ndc_corner_1) * culling_data.width_height_padding.x;

    vec3 nearest_point_on_sphere = (view_center.xyz  -  normalize(view_center.xyz))* radius;
    vec4 projected_nearest_point = projection * vec4(nearest_point_on_sphere.xyz,1);
    float level = floor(log2((width)));

    //Get 4 samples from Hi-Z
    vec4 samples;
    samples.x = textureLod( depthPyramid,ndc_corner_0, level ).x;
    samples.y = textureLod( depthPyramid,ndc_corner_1, level ).x;
    samples.z = textureLod( depthPyramid,ndc_corner_2, level ).x;
    samples.w = textureLod( depthPyramid,ndc_corner_3, level ).x;

    float max_sample   = max(max(samples.x,samples.y),max(samples.z,samples.w));
    float sphere_depth = projected_nearest_point.z/projected_nearest_point.w;
    return sphere_depth > max_sample;
}

void main(){
    if(culling_data.width_height_padding.y == 0.0f)return;
   uint gi = gl_WorkGroupID.x;
   uint ti = gl_LocalInvocationID.x;
   uint di = gi * 32 + ti;

   StaticMeshData mesh = static_meshes[di];
   vec4 center = model_matrices[mesh.mesh_id] *vec4(mesh.pos,1);
    center += vec4(mesh.center,1.0f);
   //Inflates the radius.
   float radius = mesh.radius *  max(model_matrices[mesh.mesh_id][0][0].x,max(model_matrices[mesh.mesh_id][1][1].x,model_matrices[mesh.mesh_id][2][2].x)) ;

   bool visible = true;
    for (int i = 0; i < 6; ++i)
		visible = visible && dot(culling_data.frustumPlanes[i], vec4(center.xyz, 1)) > -radius;

    if(visible)
        visible = visible && !occlusion_test(ubo.view,ubo.projection,center.xyz,radius);

   if(visible && occlusion_vibility_buffer[di] == 0)
   {
      uint command_index = atomicAdd(commands_count, 1);
      processed_commands[command_index].groupCountX              = (mesh.meshlet_count + 31)/32 ;
      processed_commands[command_index].groupCountY              = 1;
      processed_commands[command_index].groupCountZ              = 1;
      processed_commands[command_index].draw_id                  = di;
   }

   occlusion_vibility_buffer[di] = visible ? 1 :0;
}