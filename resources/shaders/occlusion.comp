#version 450
#extension GL_EXT_shader_16bit_storage: require
#extension GL_EXT_shader_8bit_storage: require
#extension GL_EXT_shader_atomic_float: require

layout(local_size_x = 32 ,local_size_y = 1 , local_size_z = 1 ) in;

#include "common.glsl"

layout(binding = 0) writeonly  buffer CommandsRead
{
	IndirectDrawDispatch processed_commands[];
};


layout(binding = 1) readonly  buffer MeshData
{
	StaticMeshData static_meshes[];
};

layout(binding = 2)  buffer CountBuffer
{
	uint commands_count;
};

layout(binding = 3)  buffer Occlusion_Buffer
{
	uint occlusion_vibility_buffer[];
};


layout(binding = 4) readonly  buffer Model_Matrices
{
	mat4 model_matrices[];
};

layout( push_constant ) uniform block
{
   CullingData culling_data;
};

// 2D Polyhedral Bounds of a Clipped, Perspective-Projected 3D Sphere. Michael Mara, Morgan McGuire. 2013
bool projectSphere(vec3 C, float r, float znear, float P00, float P11, out vec4 aabb)
{
	if (C.z < r + znear)
		return false;

	vec2 cx = -C.xz;
	vec2 vx = vec2(sqrt(dot(cx, cx) - r * r), r) / length(cx);
	vec2 minx = mat2(vx.x, vx.y, -vx.y, vx.x) * cx;
	vec2 maxx = mat2(vx.x, -vx.y, vx.y, vx.x) * cx;

	vec2 cy = -C.yz;
	vec2 vy = vec2(sqrt(dot(cy, cy) - r * r), r) / length(cy);
	vec2 miny = mat2(vy.x, -vy.y, vy.y, vy.x) * cy;
	vec2 maxy = mat2(vy.x, vy.y, -vy.y, vy.x) * cy;

	aabb = vec4(minx.x / minx.y * P00, miny.x / miny.y * P11, maxx.x / maxx.y * P00, maxy.x / maxy.y * P11) * vec4(0.5f, -0.5f, 0.5f, -0.5f) + vec4(0.5f);

	return true;
}

void main(){

   uint gi = gl_WorkGroupID.x;
   uint ti = gl_LocalInvocationID.x;
   uint di = gi * 32 + ti;

    if(occlusion_vibility_buffer[di] == 0)
        return;

   StaticMeshData mesh = static_meshes[di];
   vec4 center = model_matrices[mesh.mesh_id] *vec4(mesh.center,1);
   //Inflates the radius.
   float radius = mesh.radius *  model_matrices[mesh.mesh_id][0][0].x *1.5;

   bool visible = true;
	for (int i = 0; i < 6; ++i)
		visible = visible && dot(culling_data.frustumPlanes[i], vec4(center.xyz, 1)) > -radius;


   if(visible)
   {
      uint command_index = atomicAdd(commands_count, 1);
      processed_commands[command_index].groupCountX              = (mesh.meshlet_count + 31)/32 ;
      processed_commands[command_index].groupCountY              = 1;
      processed_commands[command_index].groupCountZ              = 1;
      processed_commands[command_index].draw_id                  = di;
   }
}