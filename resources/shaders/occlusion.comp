#version 450
#extension GL_EXT_shader_16bit_storage: require
#extension GL_EXT_shader_8bit_storage: require
#extension GL_EXT_shader_atomic_float: require

layout(local_size_x = 32 ,local_size_y = 1 , local_size_z = 1 ) in;

#include "common.glsl"

layout(set = 0 ,binding = 0) writeonly  buffer CommandsRead
{
	IndirectDrawDispatch processed_commands[];
};

layout(set = 0 ,binding = 1) readonly  buffer MeshData
{
	StaticMeshData static_meshes[];
};

layout(set = 0 ,binding = 2)  buffer CountBuffer
{
	uint commands_count;
};

layout(set = 0 ,binding = 3)  buffer Occlusion_Buffer
{
	uint occlusion_vibility_buffer[];
};

layout (set = 0 , binding = 4) uniform sampler2D depthPyramid;

layout(std430,set = 1 ,binding = 0) readonly  buffer Model_Matrices
{
	mat4 model_matrices[];
};

layout( push_constant ) uniform block
{
   CullingData culling_data;
};



// 2D Polyhedral Bounds of a Clipped, Perspective-Projected 3D Sphere. Michael Mara, Morgan McGuire. 2013
// adjusted by Arseny in his streams
bool projectSphere(vec3 C, float r, float znear, float P00, float P11, out vec4 aabb)
{
	if (C.z < r + znear)
		return false;

	vec2 cx = -C.xz;
	vec2 vx = vec2(sqrt(dot(cx, cx) - r * r), r) / length(cx);
	vec2 minx = mat2(vx.x, vx.y, -vx.y, vx.x) * cx;
	vec2 maxx = mat2(vx.x, -vx.y, vx.y, vx.x) * cx;

	vec2 cy = -C.yz;
	vec2 vy = vec2(sqrt(dot(cy, cy) - r * r), r) / length(cy);
	vec2 miny = mat2(vy.x, -vy.y, vy.y, vy.x) * cy;
	vec2 maxy = mat2(vy.x, vy.y, -vy.y, vy.x) * cy;

	aabb = vec4(minx.x / minx.y * P00, miny.x / miny.y * P11, maxx.x / maxx.y * P00, maxy.x / maxy.y * P11) * vec4(0.5f, -0.5f, 0.5f, -0.5f) + vec4(0.5f);

	return true;
}


void main(){

   uint gi = gl_WorkGroupID.x;
   uint ti = gl_LocalInvocationID.x;
   uint di = gi * 32 + ti;

   StaticMeshData mesh = static_meshes[di];
   vec4 center = model_matrices[mesh.mesh_id] *vec4(mesh.center,1);
   //Inflates the radius.
   float radius = mesh.radius *  model_matrices[mesh.mesh_id][0][0].x *1.5;

   bool visible = true;
	for (int i = 0; i < 6; ++i)
		visible = visible && dot(culling_data.frustumPlanes[i], vec4(center.xyz, 1)) > -radius;

    //Perform Occlusion Cullin Test
    if(visible)
    {
         vec4 coefficients_width_znear;
         vec4 width_height_padding;
         //Projects the sphere in a boundingbox 2D
         vec4 aabb;
         if(projectSphere(center.xyz,radius,culling_data.coefficients_width_znear.z,coefficients_width_znear.x,coefficients_width_znear.y,aabb))
         {
                float w = (aabb.z - aabb.x)* culling_data.width_height_padding.x;
                float h = (aabb.w - aabb.y) * culling_data.width_height_padding.y;
                float level = floor(log2(max(w,h)));

                float d = textureLod(depthPyramid,(aabb.x + aabb.zw)*0.5,level).x;
                float distance = culling_data.coefficients_width_znear.z/(center.z - radius);
                visible = visible && distance > d;
         }
    }

   if(visible)
   {
      uint command_index = atomicAdd(commands_count, 1);
      processed_commands[command_index].groupCountX              = (mesh.meshlet_count + 31)/32 ;
      processed_commands[command_index].groupCountY              = 1;
      processed_commands[command_index].groupCountZ              = 1;
      processed_commands[command_index].draw_id                  = di;
   }

   occlusion_vibility_buffer[di] = visible? 1 :0;
}